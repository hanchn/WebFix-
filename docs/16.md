## 1. 什么是“锁”？

> **锁**（Lock）是高并发环境下**用来保证同一份数据不会被多个线程/进程同时修改、从而导致数据混乱或不一致的机制**。

* 就像银行窗口：一次只能一个人在柜台办理业务，其他人要等前面的人“解锁”后才能操作。

---

## 2. 为什么高并发要用锁？

* 多线程/多进程/分布式场景下，**多个请求同时读写同一份数据，容易导致脏数据、冲突、丢失更新、业务异常**。
* 用“锁”可以**串行化关键代码块**，让同一时刻只有一个线程能访问共享资源，其它线程/进程只能排队等候。

---

## 3. 锁的常见类型

### 1. 本地锁（线程/进程内）

* **互斥锁（Mutex）**：只允许一个线程/进程进入临界区，Java、Python、C++等都有原生实现。
* **读写锁**：允许多个线程同时读，但写时必须独占。
* **自旋锁**：不断尝试获取锁，直到成功。

### 2. 分布式锁（多机房/多服务）

* **基于数据库的悲观锁**：如`select ... for update`
* **基于Redis的分布式锁**：如`SET key value NX PX 30000`，RedLock算法
* **基于ZooKeeper的分布式锁**：利用临时顺序节点、Watcher机制

### 3. 其它锁

* **乐观锁**：不是真的“锁”，而是通过版本号/时间戳/Compare-And-Swap（CAS）等方式实现的“冲突检测”，失败就重试。

---

## 4. 实战应用场景

* **防止超卖/超发**：电商秒杀扣库存，必须串行扣减，避免多卖。
* **账户转账**：两个账户同时操作，必须保证原子性。
* **订单号生成**：并发下不能重复。

---

## 5. 锁的常见问题和坑

* **死锁**：多个线程互相等待彼此释放锁，导致程序卡死。
* **锁粒度太粗/太细**：太粗会导致并发低，太细又难管理。
* **性能瓶颈**：高并发场景下，锁竞争严重，容易导致响应变慢。
* **分布式锁失效**：网络分区、锁续约失败、RedLock实现不严谨等，容易导致并发写入数据异常。
* **锁“误释放”**：如Redis锁，不同客户端误删了别人的锁。

---

## 6. 典型代码简例

**Java本地锁**

```java
synchronized(obj) {
    // 临界区代码
}
```

**Redis分布式锁（伪代码）**

```js
if (SET key value NX PX 30000) {
    // 获得锁，执行业务
    DEL key; // 释放锁
}
```

---

## 7. 现代替代与补充机制

* **无锁并发（lock-free）**：如CAS原语，提升性能但复杂度高
* **信号量（Semaphore）**：允许N个线程同时访问
* **队列/消息队列/分片/幂等性设计**：减少加锁的必要性

---

## 8. 总结一句话

> **高并发中的“锁”就是用来保证共享资源访问安全、数据一致的工具，但要注意性能、死锁、分布式环境下的可靠性与实现细节。**


