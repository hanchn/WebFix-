## 1. 强缓存和协商缓存的区别

### 一句话总结：

* **强缓存**：浏览器直接用本地缓存，不问服务器，**0流量，秒开**。
* **协商缓存**：浏览器先问服务器“我的缓存还能用吗？”，服务器确认后才用。

---

### 1.1 强缓存（如 Expires / Cache-Control: max-age）

* 浏览器第一次访问后把文件存在本地磁盘，并记录“过期时间”。
* 只要没有过期（还在有效期内），**再次访问时直接读本地，不发请求到服务器**，速度最快，最省流量。
* 常见 HTTP 头：

  * `Cache-Control: max-age=xxx`（以秒为单位）
  * `Expires: 时间戳`
* 例子：你在 1 小时内刷新页面，静态图片、JS 文件直接本地取。

### 1.2 协商缓存（如 Last-Modified / ETag）

* 浏览器缓存内容到了（或没有强缓存），**会带着“验证信息”请求服务器**（如 If-Modified-Since、If-None-Match）。
* 服务器比对文件有无变化。如果**没变，返回 304，浏览器用本地缓存**；如果变了，返回新内容。
* 常见 HTTP 头：

  * `Last-Modified / If-Modified-Since`
  * `ETag / If-None-Match`
* 例子：你第二天访问，浏览器带上“上次的文件签名”问服务器，服务器说没变就用本地缓存。

---

## 2. 文件地址后加随机 query，是清除缓存吗？

### 不是“清除”缓存，而是让浏览器**认为是全新的文件，不命中缓存**！

* 比如：`main.js?v=12345`
* 浏览器看到 main.js?v=12345 和 main.js?v=54321，**认为是两个不同的资源**，每次都重新请求。

### 为什么这样做？

* **文件内容变了，文件名（或 query）也变了，强制浏览器重新拉取，不用老的缓存。**
* 这叫\*\*“缓存失效/缓存穿透”方案\*\*，常用于前端发布上线时的 JS/CSS 自动加 hash 或版本号。

---

## 3. 如果不是“清除缓存”，为什么内容变了，浏览器还是缓存？

### 背后原理：

* 浏览器的缓存是**基于完整 URL 的**（包括 query 参数）。
* 只要 URL 没变，且缓存还有效，浏览器就用缓存（强缓存 or 协商缓存）。
* 如果只是内容变了但 URL 没变（比如 main.js 内容变了但还是 main.js），**强缓存期间浏览器不会重新拉取**！

---

## 4. 浏览器缓存机制简要流程

1. **强缓存**优先：没过期就直接用。
2. 强缓存过期后，走**协商缓存**：问服务器“我的缓存还能用吗？”
3. 协商缓存失效后，拉取新文件，浏览器更新本地缓存。

---

## 5. 你应该怎么做？

* 文件内容变更（如上线新版本），**文件名加 hash 或 query**，确保每次内容变时 URL 一定变。

  * main.0987abcd.js
  * main.js?v=20240522
* 这样**用户一定拿到最新内容，旧文件的缓存不会影响新文件加载**。

---

### 总结一句话

> **强缓存直接用本地，协商缓存先问服务器。加 query/hash 能让浏览器重新请求，避免拿到旧内容，但不是“清空缓存”，而是让它用不上老缓存。内容变了但 URL 没变，强缓存期内浏览器还是只用老缓存。**
